{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "y2o0b3jiipok"
      },
      "outputs": [],
      "source": [
        "# ====================\n",
        "# Section 2: Autonomous Car Class (Updated)\n",
        "# ====================\n",
        "\n",
        "class AutonomousCar:\n",
        "    def __init__(self, start_node, end_node, distance_metric, path_type, communication_strategy, reeval_interval):\n",
        "        self.start_node = start_node\n",
        "        self.end_node = end_node\n",
        "        self.distance_metric = distance_metric\n",
        "        self.path_type = path_type\n",
        "        self.communication_strategy = communication_strategy\n",
        "        self.communication_range = 800  # Fixed communication range in meters\n",
        "        self.reeval_interval = reeval_interval  # Interval for re-evaluating the route\n",
        "        self.route = self.get_route()\n",
        "        self.position_index = 0\n",
        "        self.state = \"moving\"\n",
        "        self.speed = 35  # Default speed in mph (~15.65 m/s)\n",
        "        self.shared_info = {\n",
        "            \"accidents\": set(accident_nodes),\n",
        "            \"closures\": set(road_closure_nodes),\n",
        "            \"density\": defaultdict(int),\n",
        "            \"traffic_lights\": {}  # New: node_id -> {state, time_in_state, timestamp, cycle durations}\n",
        "        }\n",
        "        self.received_messages = set()  # Track received message IDs\n",
        "        self.travel_time = 0\n",
        "        self.total_distance = 0\n",
        "        self.wait_time_at_signals = 0\n",
        "        self.rerouting_count = 0\n",
        "        self.last_reeval_time = 0\n",
        "\n",
        "    # ... (get_route, shortest_path_with_signals, get_position, move, is_in_range unchanged) ...\n",
        "\n",
        "    def communicate(self, other_cars):\n",
        "        if self.communication_strategy == 'v2v':\n",
        "            self.v2v_communicate(other_cars)\n",
        "        elif self.communication_strategy == 'centralized':\n",
        "            self.centralized_communicate()\n",
        "        elif self.communication_strategy == 'enhanced_v2v':\n",
        "            self.enhanced_v2v_communicate(other_cars)\n",
        "        elif self.communication_strategy == 'none':\n",
        "            pass\n",
        "\n",
        "    def v2v_communicate(self, other_cars):\n",
        "        current_time = time.time()\n",
        "        message_id = f\"car-{id(self)}-frame-{self.position_index}\"\n",
        "        if message_id in self.received_messages:\n",
        "            return\n",
        "        self.received_messages.add(message_id)\n",
        "\n",
        "        relevant_info = {\n",
        "            \"accidents\": {node for node in self.shared_info[\"accidents\"] if node in self.route and current_time - accident_timers.get(node, 0) >= ACCIDENT_INFO_DELAY},\n",
        "            \"closures\": {node for node in self.shared_info[\"closures\"] if node in self.route},\n",
        "        }\n",
        "\n",
        "        if not relevant_info[\"accidents\"] and not relevant_info[\"closures\"]:\n",
        "            return\n",
        "\n",
        "        for neighbor in [c for c in other_cars if self.is_in_range(c)]:\n",
        "            if message_id in neighbor.received_messages:\n",
        "                continue\n",
        "            neighbor.receive_message(relevant_info, message_id)\n",
        "\n",
        "    def enhanced_v2v_communicate(self, other_cars):\n",
        "        current_time = time.time()\n",
        "        message_id = f\"car-{id(self)}-frame-{self.position_index}\"\n",
        "        if message_id in self.received_messages:\n",
        "            return\n",
        "        self.received_messages.add(message_id)\n",
        "\n",
        "        # Collect traffic light states for nodes on the route or within 1 km\n",
        "        traffic_light_info = {}\n",
        "        current_pos = self.get_position()\n",
        "        if current_pos:\n",
        "            x1, y1 = current_pos\n",
        "            for node, tl in traffic_light_objects.items():\n",
        "                node_x, node_y = G.nodes[node]['x'], G.nodes[node]['y']\n",
        "                distance = haversine_distance(x1, y1, node_y, node_x) if self.distance_metric == 'haversine' else euclidean_distance(x1, y1, node_y, node_x)\n",
        "                if node in self.route or distance <= 1000:  # Share for route or nearby nodes\n",
        "                    traffic_light_info[node] = {\n",
        "                        \"state\": tl.get_state(),\n",
        "                        \"time_in_state\": tl.time_in_state,\n",
        "                        \"timestamp\": current_time,\n",
        "                        \"cycle_duration\": tl.cycle_duration,\n",
        "                        \"red_duration\": tl.red_duration,\n",
        "                        \"yellow_duration\": tl.yellow_duration,\n",
        "                        \"green_duration\": tl.green_duration\n",
        "                    }\n",
        "\n",
        "        relevant_info = {\n",
        "            \"accidents\": {node: {\"severity\": accident_nodes[node]} for node in self.shared_info[\"accidents\"] if node in self.route and current_time - accident_timers.get(node, 0) >= ACCIDENT_INFO_DELAY},\n",
        "            \"closures\": {node for node in self.shared_info[\"closures\"] if node in self.route},\n",
        "            \"car_speed\": self.speed,\n",
        "            \"segment_speed_limit\": self.get_segment_speed_limit(),\n",
        "            \"first_decision_node\": self.get_first_decision_node(),\n",
        "            \"traffic_lights\": traffic_light_info  # New: Share traffic light states\n",
        "        }\n",
        "\n",
        "        for neighbor in [c for c in other_cars if self.is_in_range(c)]:\n",
        "            if message_id in neighbor.received_messages:\n",
        "                continue\n",
        "            neighbor.receive_message(relevant_info, message_id)\n",
        "\n",
        "    def receive_message(self, shared_info, message_id):\n",
        "        if message_id not in self.received_messages:\n",
        "            self.received_messages.add(message_id)\n",
        "            self.shared_info[\"accidents\"].update(shared_info[\"accidents\"].keys() if isinstance(shared_info[\"accidents\"], dict) else shared_info[\"accidents\"])\n",
        "            self.shared_info[\"closures\"].update(shared_info[\"closures\"])\n",
        "            # Update traffic light states, keeping the most recent\n",
        "            current_time = time.time()\n",
        "            for node, info in shared_info.get(\"traffic_lights\", {}).items():\n",
        "                existing = self.shared_info[\"traffic_lights\"].get(node, {})\n",
        "                if not existing or info[\"timestamp\"] > existing.get(\"timestamp\", 0):\n",
        "                    self.shared_info[\"traffic_lights\"][node] = info\n",
        "\n",
        "    # ... (other methods unchanged: get_segment_speed_limit, get_first_decision_node, centralized_communicate) ...\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# ====================\n",
        "# Section 10: Main Block (Updated Simulation)\n",
        "# ====================\n",
        "\n",
        "def run_simulation(entry_exit_distribution, num_internal_cars, distance_metric, path_type, communication_strategy, consider_accidents, consider_road_closures, consider_traffic_signals, time_of_day, time_period_percentage, reeval_interval):\n",
        "    global accident_nodes, road_closure_nodes, traffic_lights, traffic_light_objects\n",
        "    \n",
        "    # Initialize cars\n",
        "    cars = []\n",
        "    for _ in range(num_internal_cars):\n",
        "        start = random.choice(internal_nodes)\n",
        "        end = random.choice(internal_nodes)\n",
        "        car = AutonomousCar(start, end, distance_metric, path_type, communication_strategy, reeval_interval)\n",
        "        if car.route:  # Only add cars with valid routes\n",
        "            cars.append(car)\n",
        "\n",
        "    # Simulation parameters\n",
        "    max_steps = 1000\n",
        "    delta_time = 1.0  # Time step in seconds\n",
        "\n",
        "    # Simulation loop\n",
        "    for step in range(max_steps):\n",
        "        # Update traffic lights\n",
        "        if consider_traffic_signals:\n",
        "            for tl in traffic_light_objects.values():\n",
        "                tl.update(delta_time)\n",
        "\n",
        "        # Update each car\n",
        "        for car in cars:\n",
        "            if car.position_index < len(car.route):\n",
        "                car.move(delta_time=delta_time)\n",
        "                car.communicate(cars)  # Share traffic light states in enhanced_v2v\n",
        "\n",
        "        # Check if all cars have reached their destinations\n",
        "        if all(car.position_index >= len(car.route) - 1 for car in cars):\n",
        "            break\n",
        "\n",
        "    # Collect metrics\n",
        "    metrics = {\n",
        "        \"average_travel_time\": np.mean([car.travel_time for car in cars]) if cars else 0,\n",
        "        \"total_reroutes\": sum(car.rerouting_count for car in cars),\n",
        "        \"average_wait_time_at_signals\": np.mean([car.wait_time_at_signals for car in cars]) if cars else 0,\n",
        "        \"total_distance_traveled\": sum(car.total_distance for car in cars),\n",
        "        \"total_travel_time\": sum(car.travel_time for car in cars),\n",
        "        \"total_wait_time_at_signals\": sum(car.wait_time_at_signals for car in cars),\n",
        "        \"average_speed\": np.mean([car.total_distance / car.travel_time if car.travel_time > 0 else 0 for car in cars]) if cars else 0,\n",
        "    }\n",
        "\n",
        "    return metrics\n",
        "\n",
        "# ... (get_user_input, run_multiple_simulations unchanged) ...\n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "machine_shape": "hm",
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}